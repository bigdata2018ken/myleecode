1、链表相关：19、21、141、206、876
2、栈相关：20,155,224,232,496,682,844
3、队列相关：剑指offer[09, 50], 2073
4、递归：剑指offer[06,16,24,25,62]
    1.问题可以拆解为子问题(子问题可以是多个，如链表的递归，往往子问题是他的next; 树的递归则是 他的左右子树)
    2.子问题的处理逻辑完全一致
    3.存在递归终止条件
    不要用人脑带入递归条件，一层一层往里绕，仅需要考虑将递归转化成 递推公式, 再由公式转化为代码
    注意点：1.调用栈过深, 可能出现栈空间溢出;2. 重复调用,多个子问题往往会出现重复计算问题，如树的遍历,需要将计算的中间结果缓存
5、排序: 215、912
    桶排序: 时间复杂度接近O(n)-O(nlogn), 将数据分为若干个桶(比如按范围划分桶), 桶之间是天然排序的, 只需要在每个桶中使用快排, 适用于外部排序
    计数排序: 桶排序的变种, 当数据范围不大时, 初始化一个索引数组(index为数据的值, value为这个值得计数), 然后在遍历原始数据时，根据这个索引
            数组找到对应的个数,来确定当前数据在排序数组中的位置。
6、二分查找 72、33
    对于已经有序的数组, 当希望搜索某个元素时(或者依赖这个元素比较时), 可以考虑用二分法
7、散列表 13
    散列函数: 对key的计算规则
    hash冲突: 根据散列函数计算得到的相同的计算结果, 常见的解决方案：开放寻址法、链表等
